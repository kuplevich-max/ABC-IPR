#include <iostream>
#include <mutex>
#include <atomic>
#include <chrono>
#include <thread>

using namespace std;

/* TASK 1 */
const int NumTasks = 1024 * 1024;
const int NumThreads[4] = { 4, 8, 16, 32 };

/* MUTEX */

mutex mtx;
int pointer = 0;

int safepointer()
{
	lock_guard<mutex> guard(mtx);
	return pointer++;
}

void processing_with_mutex(int* arr, int sleep = 0)
{
	int loc_ptr = 0;
	while (loc_ptr < NumTasks)
	{
		loc_ptr = safepointer();
		arr[loc_ptr]++;
		if (sleep)
			this_thread::sleep_for(chrono::nanoseconds(sleep));
	}
}

void task1_with_mutex(int *arr)
{
	
	for (int i = 0; i < 4; i++)
	{
		pointer = 0;
		
		auto start = chrono::high_resolution_clock::now();
		
		thread* threads = new thread[NumThreads[i]];
		    for (int j = 0; j < NumThreads[i]; j++)
			    threads[j] = thread(processing_with_mutex, arr, 0);
		
		for (int j = 0; j < NumThreads[i]; j++)
			threads[j].join();
			
		auto end = chrono::high_resolution_clock::now();
		chrono::duration<double> duration = end - start;
		cout << NumThreads[i] << " threads with mutex duration: " << duration.count() << endl;
		delete[] threads;
	}
	
	for (int i = 0; i < 4; i++)
	{
		pointer = 0;
		
		auto start = chrono::high_resolution_clock::now();
		
		thread* threads = new thread[NumThreads[i]];
		    for (int j = 0; j < NumThreads[i]; j++)
			    threads[j] = thread(processing_with_mutex, arr, 10);
		
		for (int j = 0; j < NumThreads[i]; j++)
			threads[j].join();
			
		auto end = chrono::high_resolution_clock::now();
		chrono::duration<double> duration = end - start;
		cout << NumThreads[i] << " threads with mutex duration with 10 ns sleep: " << duration.count() << endl;
		delete[] threads;
	}
	
}


/* ATOMIC */
atomic<int> atomic_pointer{0};

int getAtomicPtr(int sleep)
{
    int ptr = ++atomic_pointer;
    if(sleep)
        this_thread::sleep_for(chrono::nanoseconds(sleep));
    return ptr;
}

void processing_with_atomic(int *arr, int sleep)
{
    int loc_ptr = getAtomicPtr(sleep);
    while(loc_ptr<NumTasks)
    {
        arr[loc_ptr]++;
        loc_ptr = getAtomicPtr(sleep);
    }
}

void task1_with_atomic(int* arr)
{
    for (int i = 0; i < 4; i++)
	{
		pointer = 0;
		
		auto start = chrono::high_resolution_clock::now();
		
		thread* threads = new thread[NumThreads[i]];
		    for (int j = 0; j < NumThreads[i]; j++)
			    threads[j] = thread(processing_with_atomic, arr, 0);
		
		for (int j = 0; j < NumThreads[i]; j++)
			threads[j].join();
			
		auto end = chrono::high_resolution_clock::now();
		chrono::duration<double> duration = end - start;
		cout << NumThreads[i] << " threads with atomic duration: " << duration.count() << endl;
		delete[] threads;
	}
	
	for (int i = 0; i < 4; i++)
	{
		pointer = 0;
		
		auto start = chrono::high_resolution_clock::now();
		
		thread* threads = new thread[NumThreads[i]];
		    for (int j = 0; j < NumThreads[i]; j++)
			    threads[j] = thread(processing_with_atomic, arr, 10);
		
		for (int j = 0; j < NumThreads[i]; j++)
			threads[j].join();
			
		auto end = chrono::high_resolution_clock::now();
		chrono::duration<double> duration = end - start;
		cout << NumThreads[i] << " threads with atomic duration with 10 ns sleep: " << duration.count() << endl;
		delete[] threads;
	}
}

int main()
{
	int *arr = new int[NumTasks] {0};
	cout << "Task 1\n" << endl;
	task1_with_mutex(arr);
	task1_with_atomic(arr);
	
	
	return 0;
}

#include <iostream>
#include <mutex>
#include <atomic>
#include <chrono>
#include <thread>

using namespace std;

/* TASK 1 */
const int NumTasks = 1024 * 1024;
int NumThreads[4] = { 4, 8, 16, 32 };
mutex mtx;
int pointer = 0;

int safepointer()
{
	lock_guard<mutex> guard(mtx);
	return pointer++;
}

void processing_with_mutex(int* arr, int sleep = 0)
{
	int loc_ptr = 0;
	while (loc_ptr < NumTasks)
	{
		loc_ptr = safepointer();
		arr[loc_ptr]++;
		if (sleep)
			this_thread::sleep_for(chrono::nanoseconds(sleep));
	}
}


void task1_with_mutex(int *arr)
{
	cout << "Task1 " << endl << endl;
	
	for (int i = 0; i < 4; i++)
	{
		pointer = 0;
		
		auto start = chrono::high_resolution_clock::now();
		
		thread* threads = new thread[NumThreads[i]];
		    for (int j = 0; j < NumThreads[i]; j++)
			    threads[j] = thread(processing_with_mutex, arr, 0);
		
		for (int j = 0; j < NumThreads[i]; j++)
			threads[j].join();
			
		auto end = chrono::high_resolution_clock::now();
		chrono::duration<double> duration = end - start;
		cout << NumThreads[i] << " threads with mutex duration: " << duration.count() << endl;
		delete[] threads;
	}
	
	for (int i = 0; i < 4; i++)
	{
		pointer = 0;
		
		auto start = chrono::high_resolution_clock::now();
		
		thread* threads = new thread[NumThreads[i]];
		    for (int j = 0; j < NumThreads[i]; j++)
			    threads[j] = thread(processing_with_mutex, arr, 10);
		
		for (int j = 0; j < NumThreads[i]; j++)
			threads[j].join();
			
		auto end = chrono::high_resolution_clock::now();
		chrono::duration<double> duration = end - start;
		cout << NumThreads[i] << " threads with mutex duration with 10 ns sleep: " << duration.count() << endl;
		delete[] threads;
	}
	
}




int main()
{
	int *arr = new int[NumTasks] {0};
	task1_with_mutex(arr);
	return 0;
}
